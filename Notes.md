# Вопросы

1. Как быть с конструктором копирования и оператором копирования аллокатора: должен ли я копировать память, хранящуюся в другом аллокаторе? Если да, то нужно конструировать копированием объекты из другого, но разве это не работа контейнера? При этом, в копирующем операторе присваивания я должен сначала разрушить хранящиеся объекты - или есть гарантия, что контейнер их разрушил до вызова оператора присваивания двух аллокаторов?

2. Как освобождать память после разрушения объекта? Если я буду просто делать memmove затертого объекта оставшимися в выделенном блоке памяти, то контейнеры с узлами должны поломаться (портятся указатели на узлы); если я буду как-то учитывать занятые/пустые подблоки, то для вектора нарушается непрерывность. В большинстве примеров в интернете или книгах (смотрел в Josuttis'е) рассматривается stateless allocator, для которого эти вопросы неактуальны. Получается, что аллокаторы с внутреннем хранилищем ограничены в применимости? Т.е., например, если я учитываю свободное место, помечая освобождаемые ячейки, то могу пользоваться только контейнерами, построенными на узлах, для которых не нужна непрерывность?

*Дмитрий: 09.03.2019 в 14:59*
> Предлагаю в данной задаче принять следующее ограничение - один аллокатор может использовать только одним контейнером.
> К сожалению разные реализации STL могут отличаться в использовании аллокаторов, обчно возглавляет эту команду MSVC. Там есть труднообъяснимые копирования аллокатора внутри, как утверждается в диагностических целях.
> Это очень сильно мешает ответить на все вопросы однозначно. Тем не менее, я попробую.
> Фактически аллокатор является менеджером памяти, а не ее владельцем, поэтому его поведение в вопросах копирования сродни `std::shared_ptr`. То есть при копировании состояние должно разделяться между разными экземплярами.
> В нашем примере есть смысл рассмотреть такие варианты - все сочетания (4 штуки) копирующий/перемещающий из контейнера с идентичным/отличающимся типом аллокатора
> В нашем аллокаторе `deallocate` ничего не делает, пока не дождется, что для всех блоков была вызвана функция освобождения, можно просто счетчик вести, и как только это произойдет можно освободить заранее выделенный блок.


### Жизненный цикл объекта аллокатора

До С++11 у контейнеров были конструкторы, принимающие объект аллокатора аргументом - в частности, `std::list`:
```
explicit list(const Allocator& alloc);
explicit list(size_type count, const T& value = T(), const Allocator& alloc = Allocator());
template< class InputIt >
  list(InputIt first, InputIt last, const Allocator& alloc = Allocator());
```

Однако, управлять копированием или перемещением аллокатора при присваивании из аллокатора было нельзя. Это сильно ограничивало реализацию аллокаторов с состоянием (stateful), т.е. владеющих каким-либо ресурсом, т.к. контейнер мог копировать его по своему усмотрению. Возможно, на это можно было влиять в реализации операторов сравнения на равенство аллокаторов (но кому это сейчас нужно?).

Начиная с С++11:
- в контейнерах каждому конструктору есть пара, принимающая объект аллокатора в качестве аргумента:
```
explicit list(const Allocator& alloc);
list(size_type count, const T& value, const Allocator& alloc = Allocator());
explicit list(size_type count, const Allocator& alloc = Allocator());
template< class InputIt >
  list(InputIt first, InputIt last, const Allocator& alloc = Allocator());
list(const list& other, const Allocator& alloc);
list(list&& other, const Allocator& alloc);
list(std::initializer_list<T> init, const Allocator& alloc = Allocator());
```
- контейнеры работают с аллокаторами посредством `std::allocator_traits`, передавая хранимый объект аллокатора аргументом;
- `std::allocator_traits` использует `std::allocator_traits<allocator_type>::propagate_on_container_copy_assignment::value` (из типа аллокатора или `false`) для определения необходимости копировать объект аллокатора в операторе копирующего присваивания (`list& operator=(const list& other)`): при этом если объекты аллокаторов исходно не равны, хранимые элементы контейнера деаллоцируются старым, а копии аллоцируются через объект аллокатора присваиваемого (`other`) контейнера перед копированием элементов ([cppreference](https://en.cppreference.com/w/cpp/container/list/operator%3D));
- `std::allocator_traits` использует `std::allocator_traits<allocator_type>::propagate_on_container_move_assignment::value` (из типа аллокатора или `false`) для определения необходимости копировать объект аллокатора в операторе перемещающего присваивания (`list& operator=( list&& other );`): при этом при `false` и неравенстве объектов аллокатора каждый элемент перемещается между контейнерами индивидуально, используя при необходимости объект аллокатора присваивающего (`*this`) контейнера;
- `std::allocator_traits` использует `std::allocator_traits<allocator_type>::propagate_on_container_swap::value` (из типа аллокатора или `false`) для определения необходимости выполнить обмен объектами аллокатора при вызове метода `swap` контейнера - объекты аллокатора при этом меняются глобальной функцией `swap` (должна быть реализована для типа аллокатора), а если объекты не меняются местами и при не равны, то это считается неопределенным поведением;
- `std::allocator_traits` использует `static allocator_type allocator_type::select_on_container_copy_construction(const allocator_type& a)`, если он реализован в типе аллокатора, для оповещения копируемого объекта аллокатора о факте копирования;
- с С++17 появляется дополнительное свойство `std::allocator_traits::is_always_equal = allocator_type::is_always_equal`, позволяющее не реализовывать для типа аллокатора операторы сравнения на (не-)равенство.

Т.о., для реализации аллокатора с состоянием неплохо бы:
- во избежание неопределенного поведения определить в типе аллокатора `using propagate_on_container_swap = std::true_type;` (и реализовать глобальный `swap` для аллокаторов) либо реализовать операторы сравнения на равенство, возвращающие всегда `true` (или, с С++17 определить `using is_always_equal = std::true_type`);
- реализовать для типа аллокатора копирующее присваивание и определить `using propagate_on_container_move_assignment = std::true_type;` и `using propagate_on_container_swap = std::true_type` - однако, в силу того, что объекты аллокаторов всегда копируются, владение памятью либо не предполагается, либо, действительно, предполагается разделяемым (видимо, в том числе поэтому в `pmr` аллокатор и память разделены);
- реализовать в типе аллокатора `static allocator_type select_on_container_copy_construction(const allocator_type&)` для того, чтобы реагировать на копирование объекта аллокатора (например, менять состояние оригинала или копии перед возвратом).

### Жизненный цикл элементов контейнера

Второй вопрос возник от непонимания, как делят между собой роли контейнер и аллокатор в жизненном цикле (в частности, при удалении) хранимых элементов.
Аллокатор - посредник, он не владеет памятью, он лишь заворачивает для контейнера набор коллбэков. Отсюда, непрерывные контейнеры при удалении элемента из середины самостоятельно восстанавливают непрерывность. Для узловых контейнеров аллокатор с состоянием должен вести учет занятых и свободных ячеек, однако, чтобы этот учет был виден всем копиям объекта аллокатора, необходимо его помещать в разделяемое состояние, о чем и говорит Дмитрий.

