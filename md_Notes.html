<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>allocator: Вопросы</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">allocator
   </div>
   <div id="projectbrief">A custom allocator example</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Вопросы </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ol type="1">
<li>Как быть с конструктором копирования и оператором копирования аллокатора: должен ли я копировать память, хранящуюся в другом аллокаторе? Если да, то нужно конструировать копированием объекты из другого, но разве это не работа контейнера? При этом, в копирующем операторе присваивания я должен сначала разрушить хранящиеся объекты - или есть гарантия, что контейнер их разрушил до вызова оператора присваивания двух аллокаторов?</li>
<li>Как освобождать память после разрушения объекта? Если я буду просто делать memmove затертого объекта оставшимися в выделенном блоке памяти, то контейнеры с узлами должны поломаться (портятся указатели на узлы); если я буду как-то учитывать занятые/пустые подблоки, то для вектора нарушается непрерывность. В большинстве примеров в интернете или книгах (смотрел в Josuttis'е) рассматривается stateless allocator, для которого эти вопросы неактуальны. Получается, что аллокаторы с внутреннем хранилищем ограничены в применимости? Т.е., например, если я учитываю свободное место, помечая освобождаемые ячейки, то могу пользоваться только контейнерами, построенными на узлах, для которых не нужна непрерывность?</li>
</ol>
<p><em>Дмитрий: 09.03.2019 в 14:59</em> </p><blockquote class="doxtable">
<p>Предлагаю в данной задаче принять следующее ограничение - один аллокатор может использовать только одним контейнером. К сожалению разные реализации STL могут отличаться в использовании аллокаторов, обчно возглавляет эту команду MSVC. Там есть труднообъяснимые копирования аллокатора внутри, как утверждается в диагностических целях. Это очень сильно мешает ответить на все вопросы однозначно. Тем не менее, я попробую. Фактически аллокатор является менеджером памяти, а не ее владельцем, поэтому его поведение в вопросах копирования сродни <code>std::shared_ptr</code>. То есть при копировании состояние должно разделяться между разными экземплярами. В нашем примере есть смысл рассмотреть такие варианты - все сочетания (4 штуки) копирующий/перемещающий из контейнера с идентичным/отличающимся типом аллокатора В нашем аллокаторе <code>deallocate</code> ничего не делает, пока не дождется, что для всех блоков была вызвана функция освобождения, можно просто счетчик вести, и как только это произойдет можно освободить заранее выделенный блок. </p>
</blockquote>
<h3>Жизненный цикл объекта аллокатора</h3>
<p>До С++11 у контейнеров были конструкторы, принимающие объект аллокатора аргументом - в частности, <code>std::list</code>: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;explicit list(const Allocator&amp; alloc);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;explicit list(size_type count, const T&amp; value = T(), const Allocator&amp; alloc = Allocator());</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;template&lt; class InputIt &gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  list(InputIt first, InputIt last, const Allocator&amp; alloc = Allocator());</div></div><!-- fragment --><p>Однако, управлять копированием или перемещением аллокатора при присваивании из аллокатора было нельзя. Это сильно ограничивало реализацию аллокаторов с состоянием (stateful), т.е. владеющих каким-либо ресурсом, т.к. контейнер мог копировать его по своему усмотрению. Возможно, на это можно было влиять в реализации операторов сравнения на равенство аллокаторов (но кому это сейчас нужно?).</p>
<p>Начиная с С++11:</p><ul>
<li>в контейнерах каждому конструктору есть пара, принимающая объект аллокатора в качестве аргумента: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;explicit list(const Allocator&amp; alloc);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;list(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator());</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;explicit list(size_type count, const Allocator&amp; alloc = Allocator());</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;template&lt; class InputIt &gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  list(InputIt first, InputIt last, const Allocator&amp; alloc = Allocator());</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;list(const list&amp; other, const Allocator&amp; alloc);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;list(list&amp;&amp; other, const Allocator&amp; alloc);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;list(std::initializer_list&lt;T&gt; init, const Allocator&amp; alloc = Allocator());</div></div><!-- fragment --></li>
<li>контейнеры работают с аллокаторами посредством <code>std::allocator_traits</code>, передавая хранимый объект аллокатора аргументом;</li>
<li><code>std::allocator_traits</code> использует <code>std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</code> (из типа аллокатора или <code>false</code>) для определения необходимости копировать объект аллокатора в операторе копирующего присваивания (<code>list&amp; operator=(const list&amp; other)</code>): при этом если объекты аллокаторов исходно не равны, хранимые элементы контейнера деаллоцируются старым, а копии аллоцируются через объект аллокатора присваиваемого (<code>other</code>) контейнера перед копированием элементов (<a href="https://en.cppreference.com/w/cpp/container/list/operator%3D">cppreference</a>);</li>
<li><code>std::allocator_traits</code> использует <code>std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> (из типа аллокатора или <code>false</code>) для определения необходимости копировать объект аллокатора в операторе перемещающего присваивания (<code>list&amp; operator=( list&amp;&amp; other );</code>): при этом при <code>false</code> и неравенстве объектов аллокатора каждый элемент перемещается между контейнерами индивидуально, используя при необходимости объект аллокатора присваивающего (<code>*this</code>) контейнера;</li>
<li><code>std::allocator_traits</code> использует <code>std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code> (из типа аллокатора или <code>false</code>) для определения необходимости выполнить обмен объектами аллокатора при вызове метода <code>swap</code> контейнера - объекты аллокатора при этом меняются глобальной функцией <code>swap</code> (должна быть реализована для типа аллокатора), а если объекты не меняются местами и при не равны, то это считается неопределенным поведением;</li>
<li><code>std::allocator_traits</code> использует <code>static allocator_type allocator_type::select_on_container_copy_construction(const allocator_type&amp; a)</code>, если он реализован в типе аллокатора, для оповещения копируемого объекта аллокатора о факте копирования;</li>
<li>с С++17 появляется дополнительное свойство <code>std::allocator_traits::is_always_equal = allocator_type::is_always_equal</code>, позволяющее не реализовывать для типа аллокатора операторы сравнения на (не-)равенство.</li>
</ul>
<p>Т.о., для реализации аллокатора с состоянием неплохо бы:</p><ul>
<li>во избежание неопределенного поведения определить в типе аллокатора <code>using propagate_on_container_swap = std::true_type;</code> (и реализовать глобальный <code>swap</code> для аллокаторов) либо реализовать операторы сравнения на равенство, возвращающие всегда <code>true</code> (или, с С++17 определить <code>using is_always_equal = std::true_type</code>);</li>
<li>реализовать для типа аллокатора копирующее присваивание и определить <code>using propagate_on_container_move_assignment = std::true_type;</code> и <code>using propagate_on_container_swap = std::true_type</code> - однако, в силу того, что объекты аллокаторов всегда копируются, владение памятью либо не предполагается, либо, действительно, предполагается разделяемым (видимо, в том числе поэтому в <code>pmr</code> аллокатор и память разделены);</li>
<li>реализовать в типе аллокатора <code>static allocator_type select_on_container_copy_construction(const allocator_type&amp;)</code> для того, чтобы реагировать на копирование объекта аллокатора (например, менять состояние оригинала или копии перед возвратом).</li>
</ul>
<h3>Жизненный цикл элементов контейнера</h3>
<p>Второй вопрос возник от непонимания, как делят между собой роли контейнер и аллокатор в жизненном цикле (в частности, при удалении) хранимых элементов. Аллокатор - посредник, он не владеет памятью, он лишь заворачивает для контейнера набор коллбэков. Отсюда, непрерывные контейнеры при удалении элемента из середины самостоятельно восстанавливают непрерывность. Для узловых контейнеров аллокатор с состоянием должен вести учет занятых и свободных ячеек, однако, чтобы этот учет был виден всем копиям объекта аллокатора, необходимо его помещать в разделяемое состояние, о чем и говорит Дмитрий.</p>
<h2>pmr</h2>
<p>В докладе Pablo Halpern “Allocators: The Good Parts” рассматривает новый класс аллокторов - полиморфные (<code>std::pmr::polymorhic_allocator</code>):</p><ul>
<li>сырая работа с памятью реализуется пользователем в наследнике асбтрактного класса <code>std::memory_resource</code>, который выполняет нетипизированный <code>allocate</code> и <code>deallocate</code>;</li>
<li>пользователь не реализует сам аллокатор;</li>
<li>контейнеры, работающие с <code>std::pmr::polymorhic_allocator</code>, работают с объектом аллокатора напрямую, вызывая <code>resource()-&gt;allocate</code>, <code>construct</code>, <code>destroy</code>, <code>resource()-&gt;deallocate</code>. Pablo советует использовать только <code>std::pmr::polymoprhic_allocator&lt;std::byte&gt;</code> как наиболее понятный (вы просите байты - он возвращает байты). Безопасное и понятное использование аллокаторов сводится, на его взгляд, к нескольким правилам:</li>
<li>при копирующем присваивании контейнера копировать только объекты, но не аллокатор;</li>
<li>при перемещающем присваивании контейнера выполнять <code>swap</code> только если два контейнера используют один и тот же объект аллокатора - иначе копировать содержимое поэлементно, аллокаторы никуда не копируются, каждый контейнер использует свой объект аллокатора;</li>
<li>для каждого конструктора должна быть пара, принимающая объект аллокатора;</li>
<li>перемещающий конструктор должен всегда перемещать объект аллокатора вместе с содержимым (особенно актуально для scoped-аллокаторов), если объект аллокатора не передан дополнительным аргументом.</li>
</ul>
<p>Я не очень понял, речь только о новых полиморфных аллокаторах или о "старых" тоже, но для "старых", шаблонных, другое использование поднимает вопросы владения. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
